{"version":3,"file":"createEvented.js","sourceRoot":"","sources":["createEvented.ts"],"names":[],"mappings":";;;;;;;;;IAAA,uBAAmB,kBAAkB,CAAC,CAAA;IAEtC,wBAAoB,mBAAmB,CAAC,CAAA;IACxC,wBAAwC,YAAY,CAAC,CAAA;IACrD,kCAA+C,qBAAqB,CAAC,CAAA;IAiFrE;;OAEG;IACH,IAAM,YAAY,GAAG,IAAI,iBAAO,EAA+B,CAAC;IAEhE;;;;OAIG;IACH,sBAAyB,KAAU;QAClC,MAAM,CAAC,OAAO,CAAC,KAAK,IAAI,IAAI,IAAI,KAAK,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,UAAU,CAAC,CAAC;IAC1E,CAAC;IAED;;;OAGG;IACH,yBAAgE,QAA4B;QAC3F,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,GAAG,UAAU,KAAQ;YAChD,QAAQ,CAAC,EAAE,CAAC,EAAE,OAAA,KAAK,EAAE,CAAC,CAAC;QACxB,CAAC,GAAG,QAAQ,CAAC;IACf,CAAC;IAJe,uBAAe,kBAI9B,CAAA;IAED;;OAEG;IACH,IAAM,aAAa,GAAmB,iBAAO,CAAC;QAC5C,IAAI,YAAwB,KAAQ;YACnC,IAAM,MAAM,GAAG,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAClD,EAAE,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;gBACZ,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;YAC1B,CAAC;QACF,CAAC;QACD,EAAE,YAAC,IAAY,EAAE,QAAgC;YAChD,MAAM,CAAC,WAAE,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,EAAE,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC;QACpE,CAAC;KACD,CAAC;SACD,KAAK,CAAC;QACN,KAAK,EAAE,2BAAiB;QACxB,UAAU,YAAC,QAAiB,EAAE,OAAuB;YACpD,6BAA6B;YAC7B,YAAY,CAAC,GAAG,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;YAE/B,EAAE,CAAC,CAAC,OAAO,IAAI,WAAW,IAAI,OAAO,CAAC,CAAC,CAAC;gBACvC,GAAG,CAAC,CAAC,IAAI,SAAS,IAAI,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,EAAE,CAAC,SAAS,EAAE,OAAO,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;gBACpE,CAAC;YACF,CAAC;QACF,CAAC;KACD,CAAC,CAAC;IAEJ;sBAAe,aAAa,CAAC","sourcesContent":["import { on } from 'dojo-core/aspect';\nimport { EventObject, Handle } from 'dojo-core/interfaces';\nimport WeakMap from 'dojo-core/WeakMap';\nimport compose, { ComposeFactory } from '../compose';\nimport createDestroyable, { Destroyable } from './createDestroyable';\n\nexport interface TargettedEventObject extends EventObject {\n\t/**\n\t * The target of the event\n\t */\n\ttarget: any;\n}\n\nexport interface ActionableOptions<E extends TargettedEventObject> {\n\t[ option: string ]: any;\n\t/**\n\t * An event object\n\t */\n\tevent?: E;\n}\n\nexport interface Actionable<E extends TargettedEventObject> {\n\t/**\n\t * The *do* method of an Action, which can take a `options` property of an `event`\n\t * @param options Options passed which includes an `event` object\n\t */\n\tdo(options?: ActionableOptions<E>): any;\n}\n\nexport interface EventedCallback<E extends EventObject> {\n\t/**\n\t * A callback that takes an `event` argument\n\t * @param event The event object\n\t */\n\t(event: E): boolean | void;\n}\n\n/**\n * Either an `EventedCallback` or something that is `Actionable`\n */\nexport type EventedListener<E extends TargettedEventObject> = EventedCallback<E> | Actionable<E>;\n\n/**\n * A map of listeners where the key is the event `type`\n */\nexport interface EventedListenersMap {\n\t[type: string]: EventedListener<TargettedEventObject>;\n}\n\n/**\n * A map of callbacks where the key is the event `type`\n */\ninterface EventedCallbackMap {\n\t[type: string]: EventedCallback<EventObject>;\n}\n\nexport interface EventedOptions {\n\t/**\n\t * Any listeners that should be attached during construction\n\t */\n\tlisteners?: EventedListenersMap;\n}\n\nexport interface Evented extends Destroyable {\n\t/**\n\t * Emit an event.\n\t *\n\t * The event is determined by the `event.type`, if there are no listeners for an event type,\n\t * `emit` is essentially a noop.\n\t * @param event The `EventObject` to be delivered to listeners based on `event.type`\n\t */\n\temit<E extends EventObject>(event: E): void;\n\n\t/**\n\t * Attach a `listener` to a particular event `type`.\n\t *\n\t * @param type The event to attach the listener to\n\t * @param listener Either a function which takes an emitted `event` object, or something that is `Actionable`\n\t * @returns A handle which can be used to remove the listener\n\t */\n\ton(type: string, listener: EventedListener<TargettedEventObject>): Handle;\n}\n\nexport interface EventedFactory extends ComposeFactory<Evented, EventedOptions> { }\n\n/**\n * A weak map that contains a map of the listeners for an `Evented`\n */\nconst listenersMap = new WeakMap<Evented, EventedCallbackMap>();\n\n/**\n * A guard which determines if the value is `Actionable`\n *\n * @param value The value to guard against\n */\nfunction isActionable<T>(value: any): value is Actionable<T> {\n\treturn Boolean(value && 'do' in value && typeof value.do === 'function');\n}\n\n/**\n * An internal function that always returns an EventedCallback\n * @param listener Either a `EventedCallback` or an `Actionable`\n */\nexport function resolveListener<E extends TargettedEventObject>(listener: EventedListener<E>): EventedCallback<E> {\n\treturn isActionable(listener) ? function (event: E) {\n\t\t\tlistener.do({ event });\n\t\t} : listener;\n}\n\n/**\n * Creates a new instance of an `Evented`\n */\nconst createEvented: EventedFactory = compose({\n\t\temit<E extends EventObject>(event: E): void {\n\t\t\tconst method = listenersMap.get(this)[event.type];\n\t\t\tif (method) {\n\t\t\t\tmethod.call(this, event);\n\t\t\t}\n\t\t},\n\t\ton(type: string, listener: EventedListener<Event>): Handle {\n\t\t\treturn on(listenersMap.get(this), type, resolveListener(listener));\n\t\t}\n\t})\n\t.mixin({\n\t\tmixin: createDestroyable,\n\t\tinitialize(instance: Evented, options: EventedOptions) {\n\t\t\t/* Initialise listener map */\n\t\t\tlistenersMap.set(instance, {});\n\n\t\t\tif (options && 'listeners' in options) {\n\t\t\t\tfor (let eventType in options.listeners) {\n\t\t\t\t\tinstance.own(instance.on(eventType, options.listeners[eventType]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\nexport default createEvented;\n"]}